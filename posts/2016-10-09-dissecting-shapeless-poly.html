<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>
  <!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MGZJP4K');</script>
<!-- End Google Tag Manager -->

  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>John Doe - Dissecting Shapeless&#58; Poly</title>
<meta name="author" content="John Doe" />

<meta name="description" content="An overview of the architecture of Shapeless' Polymorphic functions (Poly).">
<meta name="keywords" content="scala, shapeless, functional programming, category theory, polymorphic function, poly, software architecture">

<!-- Facebook tags -->
<meta property="og:title" content="Dissecting Shapeless&#58; Poly">
<meta property="og:type" content="article">
<meta property="og:url" content="http://thera-example.github.io/posts/2016-10-09-dissecting-shapeless-poly.html">
<meta property="og:image" content="http://thera-example.github.io/assets/imgs/avatar_100.png">
<meta property="og:description" content="An overview of the architecture of Shapeless' Polymorphic functions (Poly).">
<meta property="og:site_name" content="A Thera-powered blog">
<meta property="og:locale" content="en-GB">

<!-- Twitter tags -->
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:description" content="An overview of the architecture of Shapeless' Polymorphic functions (Poly)." />
<meta name="twitter:title" content="Dissecting Shapeless&#58; Poly" />
<meta name="twitter:site" content="@GondolaRM" />
<meta name="twitter:image" content="http://thera-example.github.io/assets/imgs/avatar_100.png" />
<meta name="twitter:creator" content="@GondolaRM" />


  <link rel="canonical" href="http://thera-example.github.io/posts/2016-10-09-dissecting-shapeless-poly.html" />

  <link href="//fonts.googleapis.com/css?family=Open+Sans:600,800" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" href="/favicon.png">
  <link rel="alternate" type="application/atom+xml" title="John Doe" href="http://thera-example.github.io/atom.xml" />

  <link rel="stylesheet" href="/assets/all.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha256-k2/8zcNbxVIh5mnQ52A0r3a6jAgMGxFJFE2707UxGCk= sha512-ZV9KawG2Legkwp3nAlxLIVFudTauWuBpC10uEafMHYL0Sarrz5A7G79kXh5+5+woxQ5HM559XX2UZjMJ36Wplg==" crossorigin="anonymous">
</head>
<body>
  <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MGZJP4K"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->

  <div class="container">
    <div class="four columns sidebar">
      <nav>
  <h1>Hi.</h1>
  <a href="/">
    <img src="/assets/imgs/avatar_200.png" id="logo" alt="Blog logo"/>
  </a>
  <h2>I'm <a href="/">John Doe</a>.</h2>
  <div id="bio">
    <p>ðŸ’»I'm an example bio.</p>
  </div>
  <div id="social">
    Where to find me:
    <div id="stalker">
      <a title="Gondolav on Github" href="https://github.com/Gondolav">
        <i class="fa fa-github-square"></i>
      </a>

      <a title="GondolaRM on Twitter" href="https://twitter.com/GondolaRM">
        <i class="fa fa-twitter-square"></i>
      </a>

      <a title="John Doe on LinkedIn" href="https://www.linkedin.com/in/andrea-veneziano">
        <i class="fa fa-linkedin-square"></i>
      </a>
    </div>
  </div>
</nav>

    </div>

    <div class="eleven columns content">
      <p class="meta">
  Oct 09, 2016
  <a href="/">
    <i class="home fa fa-home"></i>
  </a>
</p>

<h1 class="title">Dissecting Shapeless&#58; Poly</h1>
<div id="post">
  <div class="toc">
<ul>
<li><a href="#core-principles">Core principles</a></li>
<li><a href="#architecture">Architecture</a><ul>
<li><a href="#file-structure">File structure</a></li>
<li><a href="#entities">Entities</a><ul>
<li><a href="#poly">Poly</a></li>
<li><a href="#case">Case</a></li>
<li><a href="#polyn">PolyN</a></li>
<li><a href="#natural-transformations">Natural transformations ~&gt;</a></li>
</ul></li>
</ul></li>
<li><a href="#usage">Usage</a></li>
<li><a href="#summary">Summary</a></li>
</ul>
</div>
<div class="body">
<p>In this article, I would like to analyse the architecture of Shapeless' polymorphic functions and their inner workings.</p>
<p>If you are new to Shapeless, you may want to read the first article of the series: <a href="/blog/2016/09/30/learning-shapeless-hlists.html">Learning Shapeless: HLists</a>.</p>
<p>This article does not aim to introduce polymorphic functions or provide a motivation for their usage. Its focus is to understand how the machinery behind them works. If you are new to the concept of polymorphic functions, I recommend reading the following excellent articles by Miles Sabin before proceeding with this article:</p>
<ul>
<li><a href="https://milessabin.com/blog/2012/04/27/shapeless-polymorphic-function-values-1/">First-class polymorphic function values in shapeless (1 of 3) â€” Function values in Scala</a></li>
<li><a href="https://milessabin.com/blog/2012/05/10/shapeless-polymorphic-function-values-2/">First-class polymorphic function values in shapeless (2 of 3) â€” Natural Transformations in Scala</a></li>
</ul>
<p>The article describes the architecture of Shapeless 2.3.2, which is the latest version in the moment. The architecture may be different in subsequent or previous versions, so check the version you are working with.</p>
<h1 id="core-principles">Core principles</h1>
<p>To better see the core ideas behind Shapeless' <code>Poly</code>s, let us try to implement them <em>ad hoc</em>, without any imports from Shapeless.</p>
<div class="sourceCode" include="code/shapeless-poly/src/main/scala/shapelesspoly/AdHocPoly.scala" snippet="body"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Case[F, In] {
  <span class="kw">type</span> Out
  <span class="kw">def</span> <span class="fu">apply</span>(x: In): Out
}

<span class="kw">trait</span> Poly {
  <span class="kw">def</span> apply[T](x: T)(<span class="kw">implicit</span> cse: Case[<span class="kw">this</span>.<span class="fu">type</span>, T]): cse.<span class="fu">Out</span> = <span class="fu">cse</span>(x)
}

<span class="kw">object</span> f <span class="kw">extends</span> Poly {
  <span class="kw">implicit</span> <span class="kw">val</span> intCase = <span class="kw">new</span> Case[f.<span class="fu">type</span>, Int] {
    <span class="kw">type</span> Out = String
    <span class="kw">def</span> <span class="fu">apply</span>(x: Int) = <span class="st">&quot;It works! &quot;</span> * x
  }

  <span class="kw">implicit</span> <span class="kw">val</span> stringCase = <span class="kw">new</span> Case[f.<span class="fu">type</span>, String] {
    <span class="kw">type</span> Out = Int
    <span class="kw">def</span> <span class="fu">apply</span>(x: String) = x.<span class="fu">length</span>
  }
}

<span class="fu">println</span>(<span class="fu">f</span>(<span class="dv">3</span>))
<span class="fu">println</span>(<span class="fu">f</span>(<span class="st">&quot;Foo&quot;</span>))</code></pre></div>
<p>A polymorphic function has the ability to be called with arguments of different types, possibly also returning values of different types.</p>
<p>Shapeless' <code>Poly</code> treats a computation on an argument from a particular domain <code>In</code> as a <em>behaviour</em> on that domain: On every value <code>v: In</code>, it is possible to run a computation that yields a result of type <code>Out</code>. This means that it can be encapsulated into a type class, <code>Case[In]</code>. Then, to call a function on some arbitrary type <code>T</code>, one needs to implicitly look up the type class <code>Case[T]</code> and delegate the work (including determining the result type of the computation) to it â€” this is how the <code>apply</code> method of <code>Poly</code> works.</p>
<p>To separate implicit <code>Case</code> instances of one <code>Poly</code> from those of others, <code>Case</code>s are further parameterised by the singleton type of the <code>Poly</code> they belong to: <code>Case[F, In]</code>. The <code>Poly</code> trait's <code>apply</code> method requires an implicit <code>Case</code> of the singleton type of that very <code>Poly</code>. This way, it is not possible to use a <code>Case[f.type, _]</code> to call any other function but <code>f</code>, because only <code>f</code> accepts a <code>Case</code> parameterised by <code>f.type</code>. For example:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> g <span class="kw">extends</span> Poly
<span class="fu">println</span>(<span class="fu">g</span>(<span class="dv">3</span>)(f.<span class="fu">intCase</span>))</code></pre></div>
<p>This will produce a compile-time error:</p>
<pre><code>[error]  found   : shapelesspoly.AdHocPoly.Case[shapelesspoly.AdHocPoly.f.type,Int]{type Out = String}
[error]  required: shapelesspoly.AdHocPoly.Case[shapelesspoly.AdHocPoly.g.type,Int]
[error]   println(g(3)(f.intCase))</code></pre>
<p>If you replace <code>g</code> with <code>f</code> in this call, however, it will work fine. You can think of <code>F</code> in <code>Case[F, In]</code> as a mark of ownership, tagging a <code>Case</code> as a property of a certain <code>Poly</code>.</p>
<p>Parameterising <code>Case</code>s with the type of the <code>Poly</code> they belong to has one more benefit: It is not even needed to import implicit <code>Case</code>s before calling a <code>Poly</code> that requires them. This is due to the fact that the compiler looks for the implicits in the companion objects of the types of the implicit arguments, as well as the companions of their type parameters. That is, they are a part of the <em>implicit scope</em><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. For example, <code>implicitly[Foo[A, B]]</code> will look for an implicit of this type in the companions of <code>Foo</code>, <code>A</code> and <code>B</code>. Hence, <code>Case[f.type, In]</code> will look into the companions of <code>Case</code>, <code>f.type</code> (which is simply <code>f</code>) and <code>In</code>. So, if the <code>Case</code>s are defined in the bodies of the <code>Poly</code>s they belong to, they will always be found by the implicit search when we call these <code>Poly</code>s.</p>
<h1 id="architecture">Architecture</h1>
<p>Now let us see how the ideas described above are implemented in Shapeless.</p>
<h2 id="file-structure">File structure</h2>
<p>Let us first understand which sources define polymorphic functions. We will be looking at two root directories:</p>
<ul>
<li><code>core/src/main/scala/shapeless/</code> - <code>core</code> - The human-written sources, available online <a href="https://github.com/milessabin/shapeless/tree/master/core/src/main/scala/shapeless">here</a>.</li>
<li><code>core/jvm/target/scala-2.11/src_managed/main/shapeless</code> - <code>synthetic</code> - The machine-generated sources that are produced during compilation. To gain access to them, clone the repository of Shapeless and compile it via <code>sbt compile</code>. The motivation to have <code>synthetic</code> is that it contains code for entities of different arities, which is largely boilerplate. Just open a few files from <code>synthetic</code> and look through them. You will quickly notice a pattern where each of the files contain many similar entities that vary only in the number of their arguments. It is not very efficient to define these by hand, so they are generated automatically by sbt before the compilation starts.</li>
</ul>
<p>Now let us look at the files that are of interest to us, referring for simplicity to the roots above as <code>core</code> and <code>synthetic</code>, respectively:</p>
<ul>
<li><a href="https://github.com/milessabin/shapeless/blob/master/core/src/main/scala/shapeless/poly.scala"><code>core/poly.scala</code></a> - Most of the definitions related to the polymorphic functions.</li>
<li><code>synthetic/polyapply.scala</code> - <code>PolyApply</code> trait.</li>
<li><code>synthetic/polyntraits.scala</code> - traits of the form <code>PolyN</code>, where <code>N</code> is a number between 1 and 22.</li>
<li><a href="https://github.com/milessabin/shapeless/blob/master/build.sbt"><code>build.sbt</code></a> and <a href="https://github.com/milessabin/shapeless/blob/master/project/Boilerplate.scala"><code>project/Boilerplate.scala</code></a> - These two define how the synthetic sources are generated. <code>Boilerplate.scala</code> defines the templates and the generation logic, and <code>build.sbt</code> references this file. Although they are not directly relevant to the polymorphic functions in Shapeless, they are required for mechanics behind the synthetic source generation.</li>
</ul>
<h2 id="entities">Entities</h2>
<p><a href="/plantuml-images/c11a88dcb7f493d49d4a4379a9ed49bb0f455376.svg"><img src="/plantuml-images/c11a88dcb7f493d49d4a4379a9ed49bb0f455376.svg" style="width:100.0%" /></a></p>
<h3 id="poly">Poly</h3>
<p>The base class for all the polymorphic functions is <code>Poly</code>, located in <code>core/poly.scala</code>. Together with the synthetic <code>PolyApply</code> (see the diagram above), its main job is to provide a bunch of <code>apply</code> methods for calls of different number of arguments. The methods expect the actual logic of the calls to be defined in the form of <code>Case</code> type classes that should be available implicitly. Note how each <code>Poly</code> has <code>apply</code> methods of all possible arities, enabling to define one <code>Poly</code> to be called with different number of arguments.</p>
<p>One can also think of this as polymorphism not only on the types, but on the Cartesian products of the types, expressed in the form of <code>HList</code>s. For example, one can argue that a Cartesian product of <code>A</code> and <code>B</code> can be represented with a <code>HList</code> <code>A :: B :: HNil</code>. In Scala's standard library, products are represented as tuples, so a product of <code>A</code> and <code>B</code> is <code>(A, B)</code>.</p>
<h3 id="case">Case</h3>
<p><code>Case</code> is a trait defined in <code>core/poly.scala</code>. Its highlight is a function <code>val value: L =&gt; Result</code>. It represents the logic of a <code>Poly</code> call on certain arguments <code>L</code> that returns a value of type <code>Result</code>. Note how <code>L &lt;: HList</code>. This is done so that cases of different arity can be represented with the same trait. For example, a function of one argument can be represented as <code>A :: HNil =&gt; Result</code> (instead of <code>A =&gt; Result</code>), of two arguments - <code>A :: B :: HNil =&gt; Result</code> (instead of <code>(A, B) =&gt; Result</code>) and so on.</p>
<h3 id="polyn">PolyN</h3>
<p>It may not be convenient to define <code>Case</code>s by hand using anonymous classes. Most of the time you want them to be derived from a function. Traits <code>Poly1</code> through <code>Poly22</code> exist for this reason. Located at <code>synthetic/polyntraits.scala</code>, they represent polymorphic functions of a certain arity. Their highlights are the <code>CaseBuilder</code> nested class which specialises on <code>Case</code> generation, and an <code>at</code> method to quickly get access to it. <code>CaseBuilder</code> has an <code>apply</code> method to produce <code>Case</code>s from a function, so in practice it looks like this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">val</span> caseInt: poly.<span class="fu">Case</span>[<span class="kw">this</span>.<span class="fu">type</span>, Int] = at[Int] { x: Int =&gt; x * <span class="dv">2</span> }</code></pre></div>
<p>Much more concise than, say, this:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">val</span> caseInt = <span class="kw">new</span> poly.<span class="fu">Case</span>[f.<span class="fu">type</span>, Int] {
  <span class="kw">type</span> Out = Int
  <span class="kw">def</span> <span class="fu">apply</span>(x: Int) = x * <span class="dv">2</span>
}</code></pre></div>
<h3 id="natural-transformations">Natural transformations ~&gt;</h3>
<p>Finally, one more trait worth attention is <code>~&gt;</code>, which is located in <code>core/poly.scala</code>. It exists to support <a href="https://en.wikipedia.org/wiki/Natural_transformation">natural transformations</a> and its highlight is an abstract <code>def apply[T](f : F[T]) : G[T]</code>. Note how in order to define a <code>~&gt;</code> you do not need to provide implicit <code>Case</code>s, but only to implement that <code>apply</code> method. An implicit <code>Case</code>, <code>caseUniv</code> is provided by the trait and delegates the work to the implemented <code>apply</code> method.</p>
<h1 id="usage">Usage</h1>
<p>Let us see how our <em>ad hoc</em> example from the &quot;Core Principles&quot; paragraph will look like in Shapeless:</p>
<div class="sourceCode" include="code/shapeless-poly/src/main/scala/shapelesspoly/ShapelessPoly.scala" snippet="body"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> shapeless.<span class="fu">_</span>
<span class="kw">import</span> poly.<span class="fu">_</span>

<span class="kw">object</span> f <span class="kw">extends</span> Poly1 {
  <span class="kw">implicit</span> <span class="kw">val</span> intCase    = at[Int   ] { x =&gt; <span class="st">&quot;It Works! &quot;</span> * x}
  <span class="kw">implicit</span> <span class="kw">val</span> stringCase = at[String] { x =&gt; x.<span class="fu">length</span>        }
}

<span class="fu">println</span>(<span class="fu">f</span>(<span class="dv">3</span>))
<span class="fu">println</span>(<span class="fu">f</span>(<span class="st">&quot;Foo&quot;</span>))</code></pre></div>
<p>Since we want a function defined on one argument, we extend <code>Poly1</code> to bring into the scope the convenience method <code>at</code> to build the corresponding <code>Case</code>s. The two <code>Case</code>s are for <code>Int</code> and <code>String</code> input arguments. When we call <code>at[T]</code>, we create a <code>CaseBuilder[T]</code>. When we call <code>apply(T =&gt; Result)</code> on it, a <code>Case[this.type, T]</code> is produced.</p>
<p>In the <code>main</code> method, we call <code>f</code> twice. Each time, we invoke this method in <code>PolyApply</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> apply[A](a:A)(<span class="kw">implicit</span> cse : Case[<span class="kw">this</span>.<span class="fu">type</span>, A::HNil]): cse.<span class="fu">Result</span> = <span class="fu">cse</span>(a::HNil)</code></pre></div>
<p>This method requires an implicit <code>Case</code> in the scope. Among other things, the compiler looks for it in the companion of <code>this.type</code>, since this is a type parameter of the type of the implicit argument in question. The companion of <code>this.type</code> is <code>this</code>, which is <code>object f</code>. This object contains the required implicit <code>Case</code>s for each call. After the <code>Case</code> is found, the call is delegated to this type class.</p>
<h1 id="summary">Summary</h1>
<p>The idea behind the <code>Poly</code> implementation in Shapeless is to encapsulate the execution logic in type classes for every case of input types. Hence, a concrete polymorphic function is most often implemented as an <code>object</code> that extends <code>Poly</code> and contains all the type classes for all the types this function is defined on.</p>
<p>The base framework of polymorphic functions is represented by the <code>Poly</code> trait, which represents the function, and the <code>Case</code> type class, which knows how to proceed with the call execution.</p>
<p>Besides these basic traits, Shapeless provides a set of conveniences. These include <code>PolyN</code> traits to simplify implementation of n-ary polymorphic functions and <code>~&gt;</code> trait for natural transformations.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>For further reading on the implicit scope, see the <a href="https://github.com/milessabin/export-hook#what-are-orphan-type-class-instances">export-hook readme</a>.<a href="#fnref1">â†©</a></p></li>
</ol>
</div>
</div>
</div>


      <div class="footer">
        <div class="disclaimer">
  <p>
    Â© John Doe, 2020 &mdash; built using <a href="https://github.com/swanson/lagom">Lagom theme</a>. Powered by <a href="https://github.com/scala-thera/thera">Thera</a>. The sources of this site are available on <a href="https://github.com/scala-thera/scala-thera.github.io">GitHub</a>.
  </p>
</div>
      </div>
    </div>
  </div>
</body>
</html>
